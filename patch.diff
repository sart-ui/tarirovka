*** a/include/CalibrationCore.hpp
--- b/include/CalibrationCore.hpp
@@
 #pragma once
 #include <vector>
 #include <deque>
 #include <string>
 #include <functional>
+#include <memory>
 #include <optional>
 #include <cstdint>
 
 namespace an2 {
@@
     void setSensorType(SensorType t) { type_ = t; }
     SensorType sensorType() const { return type_; }
 
     void setBaseCurve(std::shared_ptr<BaseCurveProvider> base) { base_ = std::move(base); }
     const BaseCurveProvider* baseCurve() const { return base_.get(); }
@@
     void clearPoints();
     void addPoint(double ref, double piv, bool valid, double manual);
+    // обновление точки по индексу (0..n-1)
+    bool updatePoint(std::size_t idx, double ref, double piv, bool valid, double manual);
+    // удаление точки по индексу (0..n-1), с переиндексацией FieldPoint::index
+    bool removePointByIndex(std::size_t idx);
     const std::vector<FieldPoint>& points() const { return pts_; }
 
     // Подгонка коэффициентов Δf по точкам (ref ≈ f(piv))
     FitReport fit();
@@
 private:
     SensorType type_{SensorType::NO_GOST};
     std::shared_ptr<BaseCurveProvider> base_ = std::make_shared<NullCurveProvider>();
     ChebBasis basis_{}; // degree=3, [0,1] по умолчанию
     double lambda_ = 1e-6; // слабая регуляризация
 
     std::vector<FieldPoint> pts_;
     std::vector<double> chebCoeffs_; // оценённые Δf коэффициенты
     std::optional<FitReport> lastReport_{};
 };
 
*** a/src/CalibrationCore.cpp
--- b/src/CalibrationCore.cpp
@@
 void Calibrator::clearPoints() { pts_.clear(); lastReport_.reset(); }
 
 void Calibrator::addPoint(double ref, double piv, bool valid, double manual) {
     FieldPoint fp; fp.index = (int)pts_.size()+1; fp.ref = ref; fp.piv_live = piv; fp.valid = valid; fp.manual = manual;
     pts_.push_back(fp);
 }
 
+bool Calibrator::updatePoint(std::size_t idx, double ref, double piv, bool valid, double manual) {
+    if (idx >= pts_.size()) return false;
+    pts_[idx].ref = ref;
+    pts_[idx].piv_live = piv;
+    pts_[idx].valid = valid;
+    pts_[idx].manual = manual;
+    return true;
+}
+
+bool Calibrator::removePointByIndex(std::size_t idx) {
+    if (idx >= pts_.size()) return false;
+    pts_.erase(pts_.begin()+static_cast<long>(idx));
+    // переиндексация
+    for (std::size_t i=0;i<pts_.size();++i) pts_[i].index = static_cast<int>(i+1);
+    return true;
+}
+
 FitReport Calibrator::fit() {
     FitReport rep{}; rep.n = (int)pts_.size();
     if (pts_.size() < 2) { lastReport_ = rep; return rep; }
@@
 }
 
*** a/include/ChartHelpers.hpp
--- b/include/ChartHelpers.hpp
@@
 #pragma once
 #include <QtCharts/QChartView>
 #include <QtCharts/QLineSeries>
 #include <QtCharts/QScatterSeries>
 #include <QtCharts/QAreaSeries>
 #include <QtCharts/QValueAxis>
 #include "CalibrationCore.hpp"
 
 QT_BEGIN_NAMESPACE
 class QWidget;
 QT_END_NAMESPACE
 
 namespace an2::charts {
@@
-QtCharts::QChartView* createOrUpdateChart(QtCharts::QChartView* view,
+QChartView* createOrUpdateChart(QChartView* view,
                                 const BaseCurveProvider* base,
                                 const Calibrator& calib,
                                 double tol_percent,
                                 double x0, double x1,
                                 const std::vector<FieldPoint>& points);
 
 }
 
*** a/src/ChartHelpers.cpp
--- b/src/ChartHelpers.cpp
@@
-#include <QtCharts/QChart>
+#include <QtCharts/QChart>
 #include <QtGui/QPen>
 #include <limits>
 #include <QtCore/QRandomGenerator>
 
 namespace an2::charts {
 
-static QtCharts::QLineSeries* makeSeries(const QString& name, bool pointsVisible=false) {
-    auto s = new QtCharts::QLineSeries();
+static QLineSeries* makeSeries(const QString& name, bool pointsVisible=false) {
+    auto s = new QLineSeries();
     s->setName(name);
     s->setPointsVisible(pointsVisible);
     return s;
 }
 
-static QtCharts::QScatterSeries* makeScatter(const QString& name) {
-    auto s = new QtCharts::QScatterSeries();
+static QScatterSeries* makeScatter(const QString& name) {
+    auto s = new QScatterSeries();
     s->setName(name);
-    s->setMarkerShape(QtCharts::QScatterSeries::MarkerShapeCircle);
+    s->setMarkerShape(QScatterSeries::MarkerShapeCircle);
     s->setMarkerSize(8.0);
     return s;
 }
 
-QtCharts::QChartView* createOrUpdateChart(QtCharts::QChartView* view,
+QChartView* createOrUpdateChart(QChartView* view,
                                 const BaseCurveProvider* base,
                                 const Calibrator& calib,
                                 double tol_percent,
                                 double x0, double x1,
                                 const std::vector<FieldPoint>& points) {
-    if (!view) view = new QtCharts::QChartView();
+    if (!view) view = new QChartView();
 
-    auto chart = new QtCharts::QChart();
+    auto chart = new QChart();
     chart->legend()->setVisible(true);
 
     // Базовая кривая ГОСТ
     if (base) {
         auto baseS = makeSeries(QString::fromStdString(std::string("ГОСТ: ")+base->name()));
         auto cs0 = sampleCurve([&](double x){ return base->eval(x); }, x0, x1, 200);
         for (size_t i=0;i<cs0.x.size();++i) baseS->append(cs0.x[i], cs0.y[i]);
-        QPen pen;
-        pen.setStyle(Qt::DashLine);
+        QPen pen(QColor(0, 102, 204)); // синяя
+        pen.setStyle(Qt::DashLine);
         baseS->setPen(pen);
         chart->addSeries(baseS);
     }
 
     // Подогнанная кривая
     auto fitS = makeSeries("Тарированная кривая");
     auto cs1 = sampleCurve([&](double x){ return calib.evaluate(x); }, x0, x1, 200);
     for (size_t i=0;i<cs1.x.size();++i) fitS->append(cs1.x[i], cs1.y[i]);
-    QPen penFit; penFit.setWidthF(2.2);
+    QPen penFit(QColor(255, 140, 0)); // оранжевая
+    penFit.setWidthF(2.2);
     fitS->setPen(penFit);
     chart->addSeries(fitS);
 
     // Коридор ±tol%
-    auto upper = new QtCharts::QLineSeries(); upper->setName("+");
-    auto lower = new QtCharts::QLineSeries(); lower->setName("-");
+    auto upper = new QLineSeries(); upper->setName("+");
+    auto lower = new QLineSeries(); lower->setName("-");
     for (size_t i=0;i<cs1.x.size();++i) {
         double y = cs1.y[i];
         double d = std::abs(y) * (tol_percent/100.0);
         upper->append(cs1.x[i], y + d);
         lower->append(cs1.x[i], y - d);
     }
-    auto area = new QtCharts::QAreaSeries(upper, lower);
+    auto area = new QAreaSeries(upper, lower);
     area->setName(QString("Коридор ±%1% ").arg(tol_percent));
-    area->setOpacity(0.25);
+    area->setOpacity(0.25);
+    QBrush br(QColor(200,200,200));
+    area->setBrush(br);
     chart->addSeries(area);
 
     // Точки: референсные и "Ручной ввод"
     auto refPts = makeScatter("Референсные точки");
     auto manualPts = makeScatter("Ручной ввод");
+    // Цвета точек
+    QPen refPen(QColor(0, 51, 153)); refPen.setWidthF(2.0);
+    refPts->setPen(refPen);
+    refPts->setBrush(QBrush(QColor(0, 51, 153)));
+    QPen manPen(QColor(204, 102, 0)); manPen.setWidthF(2.0);
+    manualPts->setPen(manPen);
+    manualPts->setBrush(QBrush(QColor(204, 102, 0)));
+
     for (auto &p : points) {
         refPts->append(p.piv_live, p.ref);
-        if (std::abs(p.manual - p.piv_live) > 1e-9) {
-            manualPts->append(p.piv_live, p.manual); // если хотите показывать другую ось — адаптируйте
-        }
+        manualPts->append(p.piv_live, p.manual);
     }
     chart->addSeries(refPts);
-    if (manualPts->count()>0) chart->addSeries(manualPts);
+    if (manualPts->count()>0) chart->addSeries(manualPts);
 
     // Оси
-    auto axX = new QtCharts::QValueAxis(); axX->setTitleText("ПИВ");
+    auto axX = new QValueAxis(); axX->setTitleText("ПИВ");
     axX->setLabelFormat("%.3f");
     axX->setMin(x0); axX->setMax(x1);
 
     // По Y подберём по данным
     double ymin = std::numeric_limits<double>::infinity();
@@
-    auto axY = new QtCharts::QValueAxis(); axY->setTitleText("Референс");
+    auto axY = new QValueAxis(); axY->setTitleText("Референс");
     axY->setLabelFormat("%.3f");
     if (!std::isfinite(ymin) || !std::isfinite(ymax) || ymin==ymax) { ymin = 0.0; ymax = 1.0; }
     double m = (ymax - ymin)*0.1; if (m<=0) m = 1.0;
     axY->setMin(ymin - m); axY->setMax(ymax + m);
 
     chart->addAxis(axX, Qt::AlignBottom);
     chart->addAxis(axY, Qt::AlignLeft);
 
     for (auto s : chart->series()) {
         s->attachAxis(axX);
         s->attachAxis(axY);
     }
 
     view->setChart(chart);
     view->setRenderHint(QPainter::Antialiasing);
     return view;
 }
 
 } // namespace an2::charts
 
*** a/include/TestingWindow.hpp
--- b/include/TestingWindow.hpp
@@
 #include <QtWidgets/QMainWindow>
 #include <QtWidgets/QTableWidget>
 #include <QtWidgets/QPushButton>
 #include <QtWidgets/QLineEdit>
 #include <QtWidgets/QDoubleSpinBox>
 #include <QtCore/QTimer>
 #include <QtCore/QElapsedTimer>
 #include <QtCharts/QChartView>
 #include "CalibrationCore.hpp"
 #include "GostProviders.hpp"
 
 namespace an2 {
 
 class TestingWindow : public QMainWindow {
     Q_OBJECT
 public:
     explicit TestingWindow(QWidget* parent=nullptr);
 
 private slots:
     void onConfirmRef();
-    void onStartStop();
     void onAddPoint();
-    void onAcceptValid();
+    void onDeleteRow();
+    void onClearTable();
     void onFit();
     void onZeroTrim();
     void onTick();
 
 private:
     void rebuildChart();
     void appendTableRow(const FieldPoint& fp);
+    void finalizeCurrentRow(bool valid, double mean);
 
     // Виджеты
     QTableWidget* table_{};
-    QtCharts::QChartView* chartView_{};
+    QChartView* chartView_{};
     QDoubleSpinBox* refSpin_{};         // референс
-    QDoubleSpinBox* deltaSpin_{};       // дельта стабилизации по ПИВ (в единицах ПИВ)
+    QDoubleSpinBox* deltaPercentSpin_{}; // Δ ПИВ, %
     QDoubleSpinBox* tolSpin_{};         // допуск ±% для коридора
+    QDoubleSpinBox* winSpin_{};         // окно валидности, c
+    QDoubleSpinBox* timeoutSpin_{};     // общее ожидание, c
     QPushButton* btnConfirmRef_{};
-    QPushButton* btnStartStop_{};
     QPushButton* btnAddPoint_{};
-    QPushButton* btnAcceptValid_{};
+    QPushButton* btnDeleteRow_{};
+    QPushButton* btnClear_{};
     QPushButton* btnFit_{};
     QPushButton* btnZeroTrim_{};
 
     // Модель
     SensorType type_ = SensorType::NO_GOST;
     GostFactoryConfig cfg_{}; // в демо пустой — будут заглушки
     std::shared_ptr<BaseCurveProvider> baseCurve_{};
     Calibrator calib_{};
 
     // Стабилизация
     PivStabilizer stab_{{0.2, 10.0}}; // параметры будут переустанавливаться
     QTimer timer_{};                  // таймер тиков (симуляция прихода ПИВ)
     QElapsedTimer elapsed_{};         // отсчёт времени
-    bool running_ = false;
 
     // Текущее состояние симуляции/валидации
     double currentPiv_ = 0.0;         // "бегущий" ПИВ (симуляция)
     double targetPiv_ = 0.0;          // целевое значение около референса
     double pivNoise_ = 0.05;          // шум ПИВ
+    bool validityAchieved_ = false;
+    bool timeoutFired_ = false;
 };
 
 } // namespace an2
 
*** a/src/TestingWindow.cpp
--- b/src/TestingWindow.cpp
@@
 #include <QtWidgets/QVBoxLayout>
 #include <QtWidgets/QHBoxLayout>
 #include <QtWidgets/QLabel>
 #include <QtWidgets/QHeaderView>
 #include <QtCore/QRandomGenerator>
 #include "ChartHelpers.hpp"
 
 namespace an2 {
 
 TestingWindow::TestingWindow(QWidget* parent) : QMainWindow(parent) {
     // Базовая НСХ по умолчанию
     baseCurve_ = GostFactory::create(type_, cfg_);
     calib_.setSensorType(type_);
     calib_.setBaseCurve(baseCurve_);
 
     auto* central = new QWidget();
     auto* mainL = new QVBoxLayout(central);
 
     // Верхняя панель
     auto* top = new QHBoxLayout();
     refSpin_ = new QDoubleSpinBox(); refSpin_->setDecimals(3); refSpin_->setRange(-10000, 10000);
-    deltaSpin_ = new QDoubleSpinBox(); deltaSpin_->setDecimals(3); deltaSpin_->setRange(0.0, 1000.0); deltaSpin_->setValue(0.2);
+    deltaPercentSpin_ = new QDoubleSpinBox(); deltaPercentSpin_->setDecimals(2); deltaPercentSpin_->setRange(0.0, 100.0); deltaPercentSpin_->setValue(5.0);
     tolSpin_ = new QDoubleSpinBox(); tolSpin_->setDecimals(2); tolSpin_->setRange(0.0, 100.0); tolSpin_->setValue(5.0);
+    winSpin_ = new QDoubleSpinBox(); winSpin_->setDecimals(1); winSpin_->setRange(0.1, 3600.0); winSpin_->setValue(5.0);
+    timeoutSpin_ = new QDoubleSpinBox(); timeoutSpin_->setDecimals(1); timeoutSpin_->setRange(0.1, 3600.0); timeoutSpin_->setValue(10.0);
 
     btnConfirmRef_ = new QPushButton("Подтвердить референс");
-    btnStartStop_  = new QPushButton("Старт стабилизации");
     btnAddPoint_   = new QPushButton("Добавить точку");
-    btnAcceptValid_= new QPushButton("Принять валидное");
+    btnDeleteRow_  = new QPushButton("Удалить строку");
+    btnClear_      = new QPushButton("Очистить таблицу");
     btnFit_        = new QPushButton("Подгонка модели");
     btnZeroTrim_   = new QPushButton("Zero-Trim");
 
     top->addWidget(new QLabel("Референс:")); top->addWidget(refSpin_);
-    top->addWidget(new QLabel("Δ ПИВ:"));    top->addWidget(deltaSpin_);
+    top->addWidget(new QLabel("Δ ПИВ, %:")); top->addWidget(deltaPercentSpin_);
     top->addWidget(new QLabel("Допуск, %:"));top->addWidget(tolSpin_);
+    top->addWidget(new QLabel("Окно валидн., c:")); top->addWidget(winSpin_);
+    top->addWidget(new QLabel("Ожидание, c:"));     top->addWidget(timeoutSpin_);
     top->addWidget(btnConfirmRef_);
-    top->addWidget(btnStartStop_);
     top->addWidget(btnAddPoint_);
-    top->addWidget(btnAcceptValid_);
+    top->addWidget(btnDeleteRow_);
+    top->addWidget(btnClear_);
     top->addWidget(btnFit_);
     top->addWidget(btnZeroTrim_);
 
     mainL->addLayout(top);
 
     // Таблица
     table_ = new QTableWidget(0, 5);
     QStringList headers{"#","Референс","ПИВ (live)","Валидность","Ручной ввод"};
     table_->setHorizontalHeaderLabels(headers);
     table_->horizontalHeader()->setSectionResizeMode(QHeaderView::Stretch);
     mainL->addWidget(table_, 1);
 
     // График
-    chartView_ = new QtCharts::QChartView();
+    chartView_ = new QChartView();
     mainL->addWidget(chartView_, 2);
 
     setCentralWidget(central);
     setWindowTitle("АН-2 — Тест интерфейса тарировки");
     resize(960, 720);
 
     // Сигналы
     connect(btnConfirmRef_, &QPushButton::clicked, this, &TestingWindow::onConfirmRef);
-    connect(btnStartStop_,  &QPushButton::clicked, this, &TestingWindow::onStartStop);
     connect(btnAddPoint_,   &QPushButton::clicked, this, &TestingWindow::onAddPoint);
-    connect(btnAcceptValid_,&QPushButton::clicked, this, &TestingWindow::onAcceptValid);
+    connect(btnDeleteRow_,  &QPushButton::clicked, this, &TestingWindow::onDeleteRow);
+    connect(btnClear_,      &QPushButton::clicked, this, &TestingWindow::onClearTable);
     connect(btnFit_,        &QPushButton::clicked, this, &TestingWindow::onFit);
     connect(btnZeroTrim_,   &QPushButton::clicked, this, &TestingWindow::onZeroTrim);
 
     // Таймер ПИВ-симуляции
     connect(&timer_, &QTimer::timeout, this, &TestingWindow::onTick);
     timer_.setInterval(50); // 20 Гц
 }
 
 void TestingWindow::onConfirmRef() {
-    // Подтверждение референса → запускаем таймер стабилизации
-    stab_ = PivStabilizer({deltaSpin_->value(), 10.0});
+    // Подтверждение референса → запускаем автостабилизацию
+    validityAchieved_ = false;
+    timeoutFired_ = false;
+    // абсолютная дельта из процента от целевого значения
+    const double deltaAbs = std::abs(refSpin_->value()) * (deltaPercentSpin_->value()/100.0);
+    stab_ = PivStabilizer({deltaAbs, winSpin_->value()});
     stab_.reset();
     elapsed_.restart();
 
     // Сдвигаем целевой ПИВ (симуляция)
     targetPiv_ = refSpin_->value();
     currentPiv_ = targetPiv_ + (QRandomGenerator::global()->bounded(1.0) - 0.5);
+
+    // добавляем или обновляем текущую строку
+    if (table_->rowCount()==0 || !table_->item(table_->rowCount()-1,1)) {
+        FieldPoint fp; fp.index = table_->rowCount()+1;
+        fp.ref = refSpin_->value();
+        fp.piv_live = currentPiv_;
+        fp.valid = false;
+        fp.manual = currentPiv_;
+        calib_.addPoint(fp.ref, fp.piv_live, fp.valid, fp.manual);
+        appendTableRow(fp);
+    } else {
+        // обновляем последнюю строку под новый референс
+        int r = table_->rowCount()-1;
+        table_->item(r,1)->setText(QString::number(refSpin_->value(),'f',3));
+    }
+
+    // запускаем тики
+    timer_.start();
 }
 
-void TestingWindow::onStartStop() {
-    running_ = !running_;
-    if (running_) { timer_.start(); btnStartStop_->setText("Стоп стабилизации"); }
-    else { timer_.stop(); btnStartStop_->setText("Старт стабилизации"); }
-}
-
 void TestingWindow::onAddPoint() {
     FieldPoint fp; fp.index = table_->rowCount()+1;
     fp.ref = refSpin_->value();
     fp.piv_live = currentPiv_;
     fp.valid = false;
     fp.manual = currentPiv_;
     calib_.addPoint(fp.ref, fp.piv_live, fp.valid, fp.manual);
     appendTableRow(fp);
 }
 
-void TestingWindow::onAcceptValid() {
-    // Принять валидное — теперь делается автоматически
-    int r = table_->rowCount()-1;
-    if (r>=0) {
-        table_->item(r,3)->setText("OK");
-        table_->item(r,4)->setText(table_->item(r,2)->text());
-    }
-    rebuildChart();
-}
+void TestingWindow::onDeleteRow() {
+    int r = table_->currentRow();
+    if (r<0 || r>=table_->rowCount()) return;
+    calib_.removePointByIndex(static_cast<std::size_t>(r));
+    table_->removeRow(r);
+    rebuildChart();
+}
+
+void TestingWindow::onClearTable() {
+    calib_.clearPoints();
+    table_->setRowCount(0);
+    rebuildChart();
+}
 
 void TestingWindow::onFit() {
     auto rep = calib_.fit();
     rebuildChart();
 }
@@
 void TestingWindow::onTick() {
-    if (!running_) return;
     // Симуляция прихода ПИВ вокруг targetPiv_
     double noise = (QRandomGenerator::global()->bounded(1.0) - 0.5) * 2.0 * pivNoise_;
     currentPiv_ = targetPiv_ + noise;
 
     auto st = stab_.pushSample(currentPiv_, elapsed_.elapsed());
 
     // Обновить live-ячейку таблицы в последней строке (если есть)
     int r = table_->rowCount()-1;
     if (r>=0) {
         if (!table_->item(r,2)) table_->setItem(r,2,new QTableWidgetItem());
         table_->item(r,2)->setText(QString::number(currentPiv_, 'f', 3));
         // Положим среднее как UserData для дальнейшего чтения
         table_->item(r,2)->setData(Qt::UserRole+1, st.mean);
         if (!table_->item(r,3)) table_->setItem(r,3,new QTableWidgetItem());
-        table_->item(r,3)->setText(st.stable? "OK": QString("%1/%2 c").arg(st.duration,0,'f',1).arg(10));
+        table_->item(r,3)->setText(st.stable? "OK": QString("%1/%2 c").arg(st.duration,0,'f',1).arg(winSpin_->value()));
     }
 
+    const double timeout = timeoutSpin_->value();
+    // Условия завершения
+    if (!validityAchieved_ && st.stable && st.duration >= winSpin_->value()) {
+        validityAchieved_ = true;
+        finalizeCurrentRow(true, st.mean);
+        timer_.stop();
+        return;
+    }
+    if (!timeoutFired_ && (elapsed_.elapsed()/1000.0) >= timeout) {
+        timeoutFired_ = true;
+        finalizeCurrentRow(false, st.mean);
+        timer_.stop();
+        return;
+    }
 }
 
 void TestingWindow::rebuildChart() {
     const auto xr = baseCurve_->xRange();
     chartView_ = charts::createOrUpdateChart(chartView_, baseCurve_.get(), calib_, tolSpin_->value(), xr.first, xr.second, calib_.points());
 }
 
 void TestingWindow::appendTableRow(const FieldPoint& fp) {
     int r = table_->rowCount();
     table_->insertRow(r);
     table_->setItem(r,0,new QTableWidgetItem(QString::number(fp.index)));
     table_->setItem(r,1,new QTableWidgetItem(QString::number(fp.ref, 'f', 3)));
     table_->setItem(r,2,new QTableWidgetItem(QString::number(fp.piv_live, 'f', 3)));
     table_->setItem(r,3,new QTableWidgetItem(fp.valid?"OK":"…"));
     table_->setItem(r,4,new QTableWidgetItem(QString::number(fp.manual, 'f', 3)));
 }
 
+void TestingWindow::finalizeCurrentRow(bool valid, double mean) {
+    int r = table_->rowCount()-1;
+    if (r<0) return;
+    // В модель
+    calib_.updatePoint(static_cast<std::size_t>(r),
+                       table_->item(r,1)->text().toDouble(),
+                       table_->item(r,2)->text().toDouble(),
+                       valid,
+                       mean);
+    // В таблицу
+    auto* cellValid = table_->item(r,3);
+    if (!cellValid) { cellValid = new QTableWidgetItem(); table_->setItem(r,3,cellValid); }
+    auto* cellManual = table_->item(r,4);
+    if (!cellManual) { cellManual = new QTableWidgetItem(); table_->setItem(r,4,cellManual); }
+    cellManual->setText(QString::number(mean,'f',3));
+    QBrush brush(valid ? QColor(0,160,0) : QColor(200,0,0));
+    cellManual->setForeground(brush);
+    cellValid->setText(valid ? "OK" : QString("timeout %1 c").arg(timeoutSpin_->value(),0,'f',1));
+    rebuildChart();
+}
+
 } // namespace an2